# Motivation

I want to see why stack grows down. 

> The stack pointer was chosen to run "downhill" (with the stack advancing toward lower memory) to simplify indexing into the stack from the user's program (positive indexing) and to simplify displaying the contents of the stack from a front panel.

Reference: https://tcm.computerhistory.org/ComputerTimeline/Chap37_intel_CS2.pdf

# Instructions

# Assembly

Read [arrow_down.s](./arrow_down.s), you will see that what i presented a very simplified process, but by reading it line by line, you'll be able to understand it better than just looking at the output in C. 

I didn't include the system call to print the allocated addresses (it will increase the code and operations), but you can see how and why the allocation will grows down.

## Compiling C

gcc -o output_arrow_down arrow_down.c


```bash
➜  stack_arrow_down git:(main) ✗ gcc -o output_arrow_down arrow_down.c
➜  stack_arrow_down git:(main) ✗ ./output_arrow_down 
Endereco de main_local em main: 0x16b772738
Endereco de local2 em function2: 0x16b77270c
Endereco de local3 em function3: 0x16b77270c
Endereco de local1 em function1: 0x16b7726ec
```

## Compiling Assembly generated by C 

gcc -S -o output.s arrow_down.c
gcc -c -o output.o output.s
gcc -o output output.o
./output

```bash
➜  stack_arrow_down git:(main) ✗ gcc -o stack_grows_down stack_grows_down.c
➜  stack_arrow_down git:(main) ✗ gcc -S -o output.s arrow_down.c
➜  stack_arrow_down git:(main) ✗ gcc -c -o output.o output.s
➜  stack_arrow_down git:(main) ✗ gcc -o output output.o
➜  stack_arrow_down git:(main) ✗ ./output
Endereco de main_local em main: 0x16fbbe758 --> top of stack
Endereco de local2 em function2: 0x16fbbe72c
Endereco de local3 em function3: 0x16fbbe72c
Endereco de local1 em function1: 0x16fbbe70c
```

if you want to know why we have pages and offset in allocation, see [Virtual Memory Allocation And Paging](https://ftp.gnu.org/old-gnu/Manuals/glibc-2.2.3/html_chapter/libc_3.html)